use std::fs::read_to_string;

use syn::Lit;

use crate::errors::Errors;

/// Attributes applied to a field of a `#![derive(Zusi)]` struct.
#[derive(Default)]
pub struct FieldAttrs {
    pub id: u16,
}

impl FieldAttrs {
    pub fn parse(errors: &Errors, field: &syn::Field) -> Self {
        let mut this = Self::default();

        for attr in &field.attrs {
            let ml = if let Some(ml) = zusi_attr_to_meta_list(errors, attr) {
                ml
            } else {
                continue;
            };

            for meta in &ml.nested {
                let meta = if let Some(m) = errors.expect_nested_meta(meta) { m } else { continue; };

                let name = meta.path();

                if name.is_ident("id") {
                    if let Some(m) = errors.expect_meta_name_value(&meta) {
                        this.parse_attr_id(errors, m);
                    }
                } else {
                    errors.err(
                        &meta,
                        concat!(
                        "Invalid field-level `zusi` attribute\n",
                        "Expected one of: `id`",
                        ),
                    )
                }
            }
        }

        this
    }

    fn parse_attr_id(&mut self, errors: &Errors, m: &syn::MetaNameValue) {
        if let Lit::Int(i) = &m.lit {
            match i.base10_parse::<u16>() {
                Ok(id) => self.id = id,
                Err(err) => errors.push(err),
            }
        } else {
            errors.err(&m, "Could not parse value as integer")
        }
    }
}

/// Filters out non-`#[zusi(...)]` attributes and converts to `syn::MetaList`.
fn zusi_attr_to_meta_list(errors: &Errors, attr: &syn::Attribute) -> Option<syn::MetaList> {
    if !is_zusi_attribute(attr) {
        return None;
    }
    attr_to_meta_list(errors, attr)
}

fn attr_to_meta_list(errors: &Errors, attr: &syn::Attribute) -> Option<syn::MetaList> {
    attr_to_meta_subtype(errors, attr, |m| errors.expect_meta_list(m))
}

fn attr_to_meta_subtype<R: Clone>(
    errors: &Errors,
    attr: &syn::Attribute,
    f: impl FnOnce(&syn::Meta) -> Option<&R>,
) -> Option<R> {
    match attr.parse_meta() {
        Ok(meta) => f(&meta).cloned(),
        Err(e) => {
            errors.push(e);
            None
        }
    }
}

/// Whether the attribute is one like `#[<name> ...]`
fn is_matching_attr(name: &str, attr: &syn::Attribute) -> bool {
    attr.path.segments.len() == 1 && attr.path.segments[0].ident == name
}

/// Checks for `#[doc ...]`, which is generated by doc comments.
fn is_doc_attr(attr: &syn::Attribute) -> bool {
    is_matching_attr("doc", attr)
}

/// Checks for `#[zusi ...]`
fn is_zusi_attribute(attr: &syn::Attribute) -> bool {
    is_matching_attr("zusi", attr)
}